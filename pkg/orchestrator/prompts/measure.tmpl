# Make Work

Read VISION.md, ARCHITECTURE.md, road-map.yaml, docs/specs/product-requirements/, docs/specs/use-cases/, docs/specs/test-suites/, and docs/engineering/ if they exist.

## Existing Work

The following issues already exist in the system:

```json
{{.ExistingIssues}}
```

Review what's in progress, what's completed, and what's pending.

## Instructions

Summarize:

1. What problem this project solves
2. The high-level architecture (major components and how they fit together)
3. The current state of implementation (what's done, what's in progress)
4. **Current release**: Which release we are working on and which use cases remain (check road-map.yaml)
5. Current repo size: run `mage stats` and include its output (Go production/test LOC, doc words)

Based on this, propose next steps using **release priority**:

1. **Focus on earliest incomplete release**: Prioritize completing use cases from the current release in road-map.yaml
2. **Early preview allowed**: Later use cases can be partially implemented if they share functionality with the current release
3. **Assign issues to releases**: Each issue should map to a use case in road-map.yaml; if uncertain, use release 99.0 (unscheduled)
4. Identify dependencies - what should be built first and why?

When proposing tasks:

1. **Required Reading**: List files the agent must read before starting (PRDs, ARCHITECTURE sections, existing code). This is mandatory.
2. **Files to Create/Modify**: Explicit list of packages or files to create or edit.
3. **Requirements**: What to implement.
4. **Design Decisions**: Architecture, patterns, or constraints (optional).
5. **Acceptance Criteria**: Tests and observable behavior that verify the task is done.

**Code task sizing**: Target {{.LinesMin}}-{{.LinesMax}} lines of production code per task, touching 5-7 files. Each task should do one thing: define one interface, implement one operation, add tests for one component. Split aggressively; a task that creates a struct and also implements its methods is two tasks. Prefer many small tasks over few large ones.

**Task limit**: Create no more than {{.Limit}} tasks. If more work is needed, create additional tasks in a future session.

## Output

After analyzing the project and proposing work, write the proposed tasks as a JSON file.

**IMPORTANT**: Do NOT use bd commands. Write the tasks to `{{.OutputPath}}` using the Write tool.

The JSON format is an array of task objects:

```json
[
  {
    "index": 0,
    "title": "Task title",
    "description": "Full description with Required Reading, Files to Create/Modify, Requirements, Design Decisions, Acceptance Criteria",
    "dependency": -1
  },
  {
    "index": 1,
    "title": "Task that depends on task 0",
    "description": "...",
    "dependency": 0
  }
]
```

Each task has a sequential `index` (starting at 0) and a `dependency` field. Set `dependency` to the index of the task that must be completed first, or `-1` if the task has no dependencies.

The tasks will be automatically imported into the issue tracker.
{{- if .UserInput}}

## Additional Context from User

{{.UserInput}}
{{- end}}
